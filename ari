// 線上拍貼機 - 單檔 React 元件（改良版，全面處理相機權限／無相機環境）
// 修正與強化項目：
// - 在不支援或拒絕相機權限的環境中不會丟錯誤，會顯示清楚說明與下一步按鈕
// - 使用 Permissions API（若可用）來讀取目前的相機權限狀態
// - 提供「重新請求相機」、「上傳背景影像作為替代」功能
// - 畫面合成在 canvas 上處理：若相機不可用，會使用上傳的背景或顯示預設提示
// - 妥善關閉 MediaStream（離開元件時停止 track）

import React, { useRef, useState, useEffect } from 'react';

export default function PhotoBooth() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [stream, setStream] = useState(null); // MediaStream or null
  const [permissionState, setPermissionState] = useState('unknown'); // 'granted' | 'prompt' | 'denied' | 'unsupported' | 'unknown'
  const [filter, setFilter] = useState('none');
  const [stickerFiles, setStickerFiles] = useState([]); // {id, img, x, y, scale}
  const [selectedStickerId, setSelectedStickerId] = useState(null);
  const [backgroundImg, setBackgroundImg] = useState(null);
  const [width] = useState(720);
  const [height] = useState(540);
  const [errorMsg, setErrorMsg] = useState('');

  // Check whether Permissions API can report camera permission state
  useEffect(() => {
    let mounted = true;
    async function checkPermission() {
      if (!navigator.permissions || !navigator.permissions.query) {
        // Permissions API not supported
        if (mounted) setPermissionState('unsupported');
        return;
      }
      try {
        // Note: spec names may differ — some browsers require 'camera' or 'microphone'
        const p = await navigator.permissions.query({ name: 'camera' });
        if (!mounted) return;
        setPermissionState(p.state);
        // listen for changes
        const handler = () => setPermissionState(p.state);
        p.onchange = () => setPermissionState(p.state);
      } catch (e) {
        // Some browsers throw when 'camera' is not recognized
        if (mounted) setPermissionState('unsupported');
      }
    }
    checkPermission();
    return () => { mounted = false; };
  }, []);

  // Request camera access and set stream state
  const requestCamera = async () => {
    setErrorMsg('');
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setErrorMsg('瀏覽器不支援相機存取（navigator.mediaDevices.getUserMedia 不存在）。請改用支援的瀏覽器或使用上傳背景功能。');
      setPermissionState('unsupported');
      return false;
    }

    try {
      const s = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 }, audio: false });
      // stop previous stream if exists
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
      }
      setStream(s);
      setPermissionState('granted');
      // attach to video element if mounted
      if (videoRef.current) {
        try {
          videoRef.current.srcObject = s;
          // attempt play but ignore errors (autoplay policy)
          try { await videoRef.current.play(); } catch (e) { /* ignore */ }
        } catch (e) {
          console.warn('Failed to set video srcObject', e);
        }
      }
      return true;
    } catch (e) {
      console.error('requestCamera failed', e);
      // Differentiate common error messages (Permission denied vs NotFoundError)
      const msg = (e && e.name) ? e.name : String(e);
      if (msg.includes('NotAllowed') || msg.includes('Permission')) {
        setErrorMsg('您已拒絕相機權限或瀏覽器阻擋了相機存取。請檢查網址列的鎖頭圖示或網站設定，並把相機設為「允許」。');
        setPermissionState('denied');
      } else if (msg.includes('NotFound') || msg.includes('DevicesNotFound')) {
        setErrorMsg('找不到相機裝置。請確認有接上或內建相機功能正常。');
        setPermissionState('denied');
      } else {
        setErrorMsg('無法存取相機：' + msg);
      }
      return false;
    }
  };

  // Cleanup stream when unmount or stream changes
  useEffect(() => {
    return () => {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
      }
    };
  }, [stream]);

  // draw preview onto canvas (handles video or background fallback)
  const cssFilterFromKey = (key) => {
    switch (key) {
      case 'grayscale': return 'grayscale(100%)';
      case 'sepia': return 'sepia(80%)';
      case 'invert': return 'invert(100%)';
      case 'blur': return 'blur(3px)';
      default: return 'none';
    }
  };

  const drawToCanvas = (ctx) => {
    if (!ctx) return;
    ctx.save();
    ctx.clearRect(0, 0, width, height);
    ctx.filter = cssFilterFromKey(filter);

    const hasVideo = stream && videoRef.current && videoRef.current.readyState >= 2;
    if (hasVideo) {
      // mirrored selfie
      ctx.translate(width, 0);
      ctx.scale(-1, 1);
      try { ctx.drawImage(videoRef.current, 0, 0, width, height); } catch (e) { /* sometimes drawImage may fail briefly */ }
      // reset transform
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    } else if (backgroundImg) {
      // fit-cover background
      const img = backgroundImg;
      const arCanvas = width / height;
      const arImg = img.width / img.height;
      let drawW = width, drawH = height, offsetX = 0, offsetY = 0;
      if (arImg > arCanvas) {
        drawH = height;
        drawW = img.width * (height / img.height);
        offsetX = -(drawW - width) / 2;
      } else {
        drawW = width;
        drawH = img.height * (width / img.width);
        offsetY = -(drawH - height) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
    } else {
      // placeholder
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = '#666';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('相機不可用', width / 2, height / 2 - 10);
      ctx.font = '13px sans-serif';
      ctx.fillText('請按「重新請求相機」或上傳背景圖片作為替代', width / 2, height / 2 + 14);
    }

    // stickers
    stickerFiles.forEach(s => {
      if (!s.img) return;
      ctx.save();
      const w = s.img.width * s.scale;
      const h = s.img.height * s.scale;
      ctx.drawImage(s.img, s.x - w / 2, s.y - h / 2, w, h);
      ctx.restore();
    });

    ctx.restore();
  };

  // animation loop to keep preview updating
  useEffect(() => {
    const preview = canvasRef.current;
    if (!preview) return;
    preview.width = width;
    preview.height = height;
    const ctx = preview.getContext('2d');
    let raf = 0;
    const loop = () => {
      drawToCanvas(ctx);
      raf = requestAnimationFrame(loop);
    };
    loop();
    return () => cancelAnimationFrame(raf);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [stream, filter, stickerFiles, backgroundImg]);

  // take photo (single or 4-up)
  const takePhoto = async (photostrip = false) => {
    const preview = canvasRef.current;
    if (!preview) return;
    if (!photostrip) {
      const url = preview.toDataURL('image/png');
      downloadURL(url, 'photobooth.png');
    } else {
      const rows = 4;
      const c = document.createElement('canvas');
      c.width = width;
      c.height = height * rows;
      const ctx = c.getContext('2d');
      for (let i = 0; i < rows; i++) {
        // small delay so user can change pose (optional)
        // await new Promise(r => setTimeout(r, 300));
        // copy current preview
        ctx.drawImage(preview, 0, i * height);
      }
      downloadURL(c.toDataURL('image/png'), 'photostrip.png');
    }
  };

  const downloadURL = (url, filename) => {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  };

  // Sticker upload
  const handleStickerUpload = (e) => {
    const files = Array.from(e.target.files || []);
    files.forEach(file => {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => setStickerFiles(prev => [...prev, { id: Date.now() + Math.random(), img, x: width / 2, y: height / 2, scale: 0.5 }]);
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    });
    e.target.value = null;
  };

  // Background upload (fallback)
  const handleBackgroundUpload = (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => setBackgroundImg(img);
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
    e.target.value = null;
  };

  // click canvas to move selected sticker
  const handleCanvasClick = (ev) => {
    const rect = ev.currentTarget.getBoundingClientRect();
    const cx = (ev.clientX - rect.left) * (width / rect.width);
    const cy = (ev.clientY - rect.top) * (height / rect.height);
    if (selectedStickerId) {
      setStickerFiles(prev => prev.map(s => s.id === selectedStickerId ? { ...s, x: cx, y: cy } : s));
      setSelectedStickerId(null);
    }
  };

  return (
    <div className="p-4 max-w-5xl mx-auto">
      <h2 className="text-2xl font-semibold mb-3">線上拍貼機</h2>
      <p className="mb-3 text-sm opacity-80">提示：此頁面需要 HTTPS 才能使用相機（瀏覽器安全策略）。若相機無法使用，可上傳背景圖片作為替代。</p>

      {errorMsg && (
        <div className="bg-red-100 text-red-700 p-2 mb-3 rounded">
          {errorMsg}
        </div>
      )}

      <div className="mb-3 flex gap-2 items-center">
        <button onClick={requestCamera} className="px-3 py-2 rounded bg-indigo-600 text-white">重新請求相機</button>
        <label className="cursor-pointer px-3 py-2 bg-gray-200 rounded">
          上傳背景
          <input type="file" accept="image/*" onChange={handleBackgroundUpload} className="hidden" />
        </label>
        <div className="text-sm text-gray-600">相機權限：{permissionState}</div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="md:col-span-2 space-y-3">
          <div className="bg-gray-100 rounded-lg p-2 flex flex-col items-center">
            <div className="relative">
              <video ref={videoRef} className="hidden" playsInline muted></video>
              <canvas ref={canvasRef} onClick={handleCanvasClick} style={{ width: '100%', maxWidth: '720px', height: 'auto', cursor: selectedStickerId ? 'crosshair' : 'default', borderRadius: 8, boxShadow: '0 6px 18px rgba(0,0,0,0.12)' }} />
              <div className="absolute left-2 top-2 text-xs bg-black bg-opacity-30 text-white rounded px-2 py-1">Preview - filter: {filter}</div>
            </div>

            <div className="mt-3 flex gap-2 flex-wrap">
              <button className="px-3 py-2 rounded bg-blue-600 text-white" onClick={() => takePhoto(false)}>拍照(下載)</button>
              <button className="px-3 py-2 rounded bg-pink-600 text-white" onClick={() => takePhoto(true)}>拍貼條(4張)</button>
              <select value={filter} onChange={e => setFilter(e.target.value)} className="px-2 py-1 rounded border">
                <option value="none">無濾鏡</option>
                <option value="grayscale">黑白</option>
                <option value="sepia">古銅</option>
                <option value="invert">反轉</option>
                <option value="blur">模糊</option>
              </select>
            </div>
          </div>

          <div className="mt-2 bg-white rounded p-3 shadow">
            <h3 className="font-medium mb-2">貼圖管理</h3>
            <label className="cursor-pointer px-3 py-2 bg-gray-200 rounded">上傳貼圖
              <input type="file" accept="image/*" multiple onChange={handleStickerUpload} className="hidden" />
            </label>

            <div className="mt-3 grid grid-cols-2 gap-2">
              {stickerFiles.length === 0 ? <div className="text-sm opacity-60">尚未上傳貼圖</div> : stickerFiles.map(s => (
                <div key={s.id} className="flex items-center gap-2 border rounded p-2">
                  <img src={s.img.src} alt="sticker" style={{ width: 64, height: 64, objectFit: 'contain' }} />
                  <div className="flex-1">
                    <div className="flex gap-1">
                      <button className="px-2 py-1 rounded bg-yellow-300 text-sm" onClick={() => setSelectedStickerId(s.id)}>選取/移動</button>
                      <button className="px-2 py-1 rounded bg-gray-200 text-sm" onClick={() => setStickerFiles(prev => prev.map(st => st.id === s.id ? { ...st, scale: Math.min(2, st.scale + 0.1) } : st))}>放大</button>
                      <button className="px-2 py-1 rounded bg-gray-200 text-sm" onClick={() => setStickerFiles(prev => prev.map(st => st.id === s.id ? { ...st, scale: Math.max(0.1, st.scale - 0.1) } : st))}>縮小</button>
                      <button className="px-2 py-1 rounded bg-red-400 text-white text-sm" onClick={() => setStickerFiles(prev => prev.filter(st => st.id !== s.id))}>刪除</button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>

        <aside className="space-y-3">
          <div className="bg-white rounded p-3 shadow">
            <h4 className="font-medium mb-2">說明</h4>
            <ul className="text-sm list-disc pl-4 space-y-1">
              <li>若無法開啟相機：1) 確認頁面為 HTTPS；2) 點網址列左側鎖頭圖示檢查相機權限；3) 若先前拒絕過，請到瀏覽器網站設定重設權限後再重新請求相機。</li>
              <li>按「重新請求相機」會觸發瀏覽器的權限請求（若瀏覽器允許）。</li>
              <li>可上傳背景影像作為相機的替代來拍攝合成圖。</li>
              <li>建議在 Chrome/Edge/Firefox 等桌面瀏覽器使用，手機瀏覽器或 sandboxed environment 可能會限制相機權限。</li>
            </ul>
          </div>

          <div className="bg-white rounded p-3 shadow">
            <h4 className="font-medium mb-2">快速檢查清單</h4>
            <ol className="text-sm list-decimal pl-4 space-y-1">
              <li>網址是否為 HTTPS？（否：無法使用 getUserMedia）</li>
              <li>瀏覽器是否已允許相機？（鎖頭 → 相機 → 允許）</li>
              <li>是否有其他分頁或應用正在佔用相機？關閉後重試。</li>
            </ol>
          </div>
        </aside>
      </div>
    </div>
  );
}
